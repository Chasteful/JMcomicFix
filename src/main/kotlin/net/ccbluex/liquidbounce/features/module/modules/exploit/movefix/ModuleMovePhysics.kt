package net.ccbluex.liquidbounce.features.module.modules.exploit.movefix

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.event.events.PacketEvent
import net.ccbluex.liquidbounce.event.events.PlayerMoveEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.event.tickHandler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.ClientModule
import net.ccbluex.liquidbounce.features.module.modules.combat.killaura.ModuleKillAura
import net.ccbluex.liquidbounce.lang.translation
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.utils.client.isEqual1_8
import net.ccbluex.liquidbounce.utils.client.markAsError
import net.ccbluex.liquidbounce.utils.client.send1_8PlayerInput
import net.ccbluex.liquidbounce.utils.client.usesViaFabricPlus
import net.minecraft.client.network.ClientPlayerEntity
import net.minecraft.entity.MovementType
import net.minecraft.network.PacketByteBuf
import net.minecraft.network.packet.s2c.common.CustomPayloadS2CPacket
import net.minecraft.network.packet.s2c.play.EntityVelocityUpdateS2CPacket
import net.minecraft.util.Identifier
import net.minecraft.util.math.Vec3d
import kotlin.math.cos
import kotlin.math.min
import kotlin.math.sin
import kotlin.math.sqrt

object ModuleMovePhysics : ClientModule("MovePhysics", Category.EXPLOIT, aliases = arrayOf("MoveFix")) {
    private var jumpFunny = 0
    var jumpTicks = 0L
    private val physics = NoaPhysics()
    private var groundTicks = 0
    private var lastMotionY = 0.0
    private var wasClimbing = false

    private val spiderValue by boolean("Spider", true)
    val damageSpeed by boolean("Damage Speed", true)
    override fun onEnabled() {
        super.onEnabled()
        resetMinibloxState()
    }

    override fun onDisabled() {
        super.Disabled()
        resetMinibloxState()
    }

    private fun resetMinibloxState() {
        jumpFunny = 0
        jumpTicks = 0
        physics.reset()
        groundTicks = 0
        lastMotionY = 0.0
        wasClimbing = false
    }

    @Suppress("unused")
    private val tick = tickHandler {
        if (!usesViaFabricPlus || !isEqual1_8) {
            chat(markAsError(translation("liquidbounce.module.disabler.messages.minibloxdProtocol")))
            enabled = false
            return@tickHandler
        }
        val player = mc.player ?: return@tickHandler

        if (player.isOnGround) {
            groundTicks++
            if (groundTicks > 5) jumpFunny = 0
        } else {
            groundTicks = 0
        }

        if (player.verticalCollision && lastMotionY > 0 && player.velocity.y <= 0) {
            physics.velocity.y = 0.0
            physics.impulse.y = 0.0
        }

        lastMotionY = player.velocity.y


        send1_8PlayerInput(
            player.input.movementSideways,
            player.input.movementForward,
            player.jumping,
            player.isSneaking
        )
    }

    @Suppress("unused")
    private val moveHandler = handler<PlayerMoveEvent> { event ->
        if (event.type != MovementType.SELF) return@handler
        val player = mc.player ?: return@handler

        if (player.isOnGround && physics.velocity.y < 0) {
            physics.velocity.set(0.0, 0.0, 0.0)
        }


        if (player.velocity.y in 0.4199..0.4201) {
            jumpFunny = min(jumpFunny + 1, 3)
            physics.impulse.add(0.0, 8.0, 0.0)
        }


        if (spiderValue && player.horizontalCollision && player.input.hasForwardMovement()) {
            physics.velocity.set(0.0, 8.0, 0.0)
            wasClimbing = true
        } else if (wasClimbing) {
            physics.velocity.set(0.0, 0.0, 0.0)
            wasClimbing = false
        }

        physics.gravityMultiplier =
            if (ModuleKillAura.targetTracker.target != null && physics.velocity.y >= 0) 4.0 else 2.0

        val speed = getBloxdSpeed(player)
        val moveVec = getMoveDirection(
            player.input.movementForward.toDouble(),
            player.input.movementSideways.toDouble(),
            speed,
            player
        )


        event.movement = Vec3d(
            moveVec.x,
            physics.getMotionForTick().y * (1.0 / 30.0),
            moveVec.z
        )
    }

    private fun getBloxdSpeed(player: ClientPlayerEntity): Double {
        if (System.currentTimeMillis() < jumpTicks) return 1.0
        if (player.isUsingItem) return 0.06
        return 0.1505 + 0.025 * (0.1505 / 0.26) * jumpFunny
    }

    private fun getMoveDirection(forward: Double, strafe: Double, speed: Double, player: ClientPlayerEntity): Vec3d {
        if (forward == 0.0 && strafe == 0.0) return Vec3d.ZERO
        var f = forward
        var s = strafe
        val mag = sqrt(f * f + s * s)
        if (mag > 1.0) {
            f /= mag
            s /= mag
        }
        val rad = Math.toRadians(player.yaw.toDouble())
        val sin = sin(rad)
        val cos = cos(rad)
        val x = (s * cos - f * sin) * speed
        val z = (f * cos + s * sin) * speed
        return Vec3d(x, 0.0, z)
    }

    @Suppress("unused")
    private val packetHandler = handler<PacketEvent> { event ->
        val player = mc.player ?: return@handler
        when (val packet = event.packet) {
            is EntityVelocityUpdateS2CPacket -> {
                if (packet.entityId == player.id && damageSpeed) {
                    jumpTicks = System.currentTimeMillis() + 1300
                }
            }

            is CustomPayloadS2CPacket -> {
                if (packet.payload.id == Identifier.of("bloxd", "resyncphysics")) {
                    try {
                        val buf = PacketByteBuf(Unpooled.buffer())
                        with(packet) { buf }
                        jumpFunny = 0
                        physics.impulse.set(0.0, 0.0, 0.0)
                        physics.force.set(0.0, 0.0, 0.0)
                        physics.velocity.set(
                            buf.readFloat().toDouble(),
                            buf.readFloat().toDouble(),
                            buf.readFloat().toDouble()
                        )
                    } catch (_: Exception) {
                    }
                }
            }
        }
    }

    private class MutableVec3d(var x: Double, var y: Double, var z: Double) {
        fun set(x: Double, y: Double, z: Double) {
            this.x = x; this.y = y; this.z = z
        }

        fun add(x: Double, y: Double, z: Double) {
            this.x += x; this.y += y; this.z += z
        }

        fun mul(factor: Double) {
            x *= factor; y *= factor; z *= factor
        }
    }

    private class NoaPhysics {
        val impulse = MutableVec3d(0.0, 0.0, 0.0)
        val force = MutableVec3d(0.0, 0.0, 0.0)
        val velocity = MutableVec3d(0.0, 0.0, 0.0)
        private val gravity = MutableVec3d(0.0, -10.0, 0.0)
        var gravityMultiplier = 2.0
        private val delta = 1.0 / 30.0
        private val mass = 1.0

        fun reset() {
            impulse.set(0.0, 0.0, 0.0)
            force.set(0.0, 0.0, 0.0)
            velocity.set(0.0, 0.0, 0.0)
        }

        fun getMotionForTick(): MutableVec3d {
            val massDiv = 1.0 / mass
            force.mul(massDiv)
            force.add(gravity.x, gravity.y, gravity.z)
            force.mul(gravityMultiplier)
            impulse.mul(massDiv)
            force.mul(delta)
            impulse.add(force.x, force.y, force.z)
            velocity.add(impulse.x, impulse.y, impulse.z)
            force.set(0.0, 0.0, 0.0)
            impulse.set(0.0, 0.0, 0.0)
            return velocity
        }
    }
}
