package net.ccbluex.liquidbounce.features.module.modules.exploit.phase.modes

import net.ccbluex.liquidbounce.config.types.Choice
import net.ccbluex.liquidbounce.config.types.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.tickHandler
import net.ccbluex.liquidbounce.features.module.modules.exploit.phase.ModulePhase
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionAndOnGround
import kotlin.math.cos
import kotlin.math.sin
object PhaseVanilla : Choice("Vanilla") {
    override val parent: ChoiceConfigurable<*>
        get() = ModulePhase.mode

    @Suppress("unused")
    private val tickHandler = tickHandler {
        if (player.isOnGround && player.horizontalCollision && !player.isInsideWall) {

            network.sendPacket(PositionAndOnGround(
                player.x, player.y, player.z, true, true))
            network.sendPacket(PositionAndOnGround(
                0.5, 0.0, 0.5, true, true))
            network.sendPacket(PositionAndOnGround(
                player.x, player.y, player.z, true, true))
            network.sendPacket(PositionAndOnGround(
                player.x, player.y + 0.2, player.z, true, true))
            network.sendPacket(PositionAndOnGround(
                0.5, 0.0, 0.5, true, true))
            network.sendPacket(PositionAndOnGround(
                player.x + 0.5, player.y, player.z + 0.5, true, true))

            val yaw = Math.toRadians(player.yaw.toDouble())
            val x = -sin(yaw) * 0.04
            val z = cos(yaw) * 0.04

            player.setPosition(player.x + x, player.y, player.z + z)
        }
    }
}
