package net.ccbluex.liquidbounce.features.module.modules.exploit.phase.modes

import net.ccbluex.liquidbounce.config.types.nesting.Choice
import net.ccbluex.liquidbounce.config.types.nesting.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.events.PlayerMoveEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.modules.exploit.phase.ModulePhase
import net.ccbluex.liquidbounce.utils.entity.direction
import net.ccbluex.liquidbounce.utils.entity.moving
import net.ccbluex.liquidbounce.utils.kotlin.step
import kotlin.math.cos
import kotlin.math.sin

object PhaseFullBlock : Choice("FullBlock") {
    override val parent: ChoiceConfigurable<*>
        get() = ModulePhase.mode

    private var clipState = 0
    private var shouldContinue = false
    private var phaseValue = 0.0
    private var yaw = 0.0

    override fun enable()
        shouldContinue = false
        clipState = 0
        phaseValue = 0.0
        player.noClip = true
        super.enable()
    }

    override fun disable()
        player.noClip = false
        super.Disabled()
    }

    @Suppress("unused")
    private val moveHandler = handler<PlayerMoveEvent> { event ->
        if (player.horizontalCollision) {
            clipState++
        }

        when (clipState) {
            1 -> {
                val direction = Math.toRadians(player.yaw.toDouble())
                val cos = cos(direction)
                val sin = sin(direction)

                for (i in 0.025..2.0 step 0.025) {
                    shouldContinue = false

                    // 检查目标位置是否可通行
                    if (!player.moving|| world.getBlockCollisions(
                            player,
                            player.boundingBox.offset(-sin * i, 0.0, cos * i)
                        ).iterator().hasNext()) {
                        continue
                    }


                    player.setPosition(
                        player.x - sin * 0.06,
                        player.y,
                        player.z + cos * 0.06
                    )

                    if (i > 0.06) {
                        phaseValue = i
                        yaw = direction
                        shouldContinue = true
                    }

                    event.movement.x = 0.0
                    event.movement.z = 0.0
                    break
                }

                clipState++
                if (!shouldContinue) {
                    clipState = 0
                }
            }

            2 -> {
                val value = if (player.moving) phaseValue else -0.06
                player.setPosition(
                    player.x - sin(yaw) * value,
                    player.y,
                    player.z + cos(yaw) * value
                )
                clipState = 0
            }
        }
    }
}
